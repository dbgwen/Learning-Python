## Lists in Python

* .insert() allows us to add an element to a specific index in a list
    
    The .insert() method takes in two inputs:
      1. The index you want to insert into.
      2. The element you want to insert at the specified index.
      
      store_line.insert(2, "Vikor")
      print(store_line) 
      
      All elements from the specified index and up to the last index are shifted one index to the right. 
      This does not apply to inserting an element to the very end of a list as it will simply add an additional index.
      
* .pop() allows us to remove elements at a specific index 
      
      The .pop() method takes an optional single input:
        1. The index for the element you want to remove.
        
      The method can be called without a specific index. 
      Using .pop() without an index will remove whatever the last element of the list is.
      
      .pop() is unique in that it will return the value that was removed. 
      If we wanted to know what element was deleted, simply assign a variable to the call of the .pop() method. 
      
* range() - creates an object of a list of consecutive numbers, starting at 0 and ending at the number before the input

      Convert range() to a list using list(range())
      range() has three potential inputs: range(starting number, ending number, skip number)
      range(2, 12, 3) - outputs a list starting at 2, repeating every three numbers and ending on 11
       
* len() - finds the number of items in a list ("length")
      
      len() 
      print(len())
      
* Slicing - extracts a portion of a list to make a new list

      list_name[start:end]
        - start is the index of the first element that we want to include in our selection
        - end is the index of one more than the last index that we want to include
        
       suitcase = ["shirt", "shirt", "pants", "pants", "pajamas", "books"]
       beginning = suitcase[0:2] - extracts first two elements
       
       list_name[:n] - extracts the first n elements of a list
          fruits[:3] - extracts the list from 0 and up to index 3 (not including 3)
          
        list_name[-n:] - extracts the last n elements
          fruits[-2:] - extracts the last two items on a list
        
        list_name[:-n] - extracts all but n last elements of a list
          fruits[:-1] - extracts from 0 up to last element on list
          
 * .count() - count occurrences of an item in a list
        
        since .count() returns a value, we can assign it to a variable to use it
        Can use .count() to count element appearances in a two-dimensional list [num1, num2]
        
 * .sort() - sorts a list, modifies it directly
 
        .sort() - sorts list of names in alphabetical order
        .sort(reverse=True) - sorts in reverse
        
        The .sort() method does not return any value and thus does not need to be assigned to a variable since it modifies the list directly. 
        If we do assign the result of the method, it would assign the value of None to the variable.
        
 * sorted() - built-in function that creates new list
 
        sorted() differs from .sort() in two ways:
          1. It comes before a list in stead of after
          2. It generates a new list rather than modifying the one that already exists

 
        
    ## List Examples
  
        A function that returns the sum of the first and last elements of a given list might look like this:
              def first_plus_last(lst):
              return lst[0] + lst[-1]

        We can get the length and append it at the same time by nesting the function calls as shown in the solution. 
        Afterward, we return the modified list.
                def append_size(lst):
                lst.append(len(lst))
                return lst
  
        Write a function named larger_list that has two parameters named lst1 and lst2. 
        The function should return the last element of the list that contains more elements. 
        If both lists are the same size, then return the last element of lst1.
        
                def larger_list(lst1, lst2):
                  if len(lst1) >= len(lst2): (use >= to compare lengths of lists)
                    return lst1[-1] 
                  else:
                    return lst2[-1]
                    
        The function should combine these two lists into one new list and sort the result. Return the new sorted list.
        
                def combine_sort(lst1, lst2):
                  unsorted = lst1 + lst2
                  combine = sorted(unsorted)
                  return combine
                  
         Create a function named remove_middle which has three parameters named lst, start, and end.
         The function should return a list where all elements in lst with an index between start and end (inclusive) have been removed
         
                def remove_middle(lst, start, end):
                    return lst[:start] + lst[end+1:]

          Create a function named more_frequent_item that has three parameters named lst, item1, and item2.
          Return either item1 or item2 depending on which item appears more often in lst.
          If the two items appear the same number of times, return item1.
          
                def more_frequent_item(lst, item1, item2):
                  if lst.count(item1) >= lst.count(item2):
                    return item1 
                  else: 
                    return item2
                    
          Create a function named double_index that has two parameters: a list named lst and a single number named index.
          The function should return a new list where all elements are the same as in lst except for the element at index. 
          The element at index should be double the value of the element at index of the original lst.
          If index is not a valid index, the function should return the original list.
          
                def double_index(lst, index):
                  if index >= len(lst):
                    return lst
                  else:
                    new_lst = lst[0:index]
                  new_lst.append(lst[index]*2)
                  new_lst = new_lst + lst[index+1:]
                  return new_lst
                    
           Create a function called middle_element that has one parameter named lst.
           If there are an odd number of elements in lst, the function should return the middle element. 
           If there are an even number of elements, the function should return the average of the middle two elements.   
           
                 def middle_element(lst): 
                      if len(lst) % 2 == 0:
                        sum = lst[int(len(lst)/2)] + lst[int(len(lst)/2) - 1]
                        return sum / 2
                      else: 
                        return lst[int(len(lst)/2)]
                        
                        
## Tuples 
 
    Data structure in Python that lets us store multiple data types inside one object - it is immutable - can't be changed
    Interact with tuples like a list, except once it is created we change or modify it - the order of the tuple is very important
    Sometimes it is useful to have an immutable list
    
    - Unpack a tuple by creating variables from the tuple
    - Creating a one element tuple - have to use a comma after the first element ("trailing comma")
    
*
    
